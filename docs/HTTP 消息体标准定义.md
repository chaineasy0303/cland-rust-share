# HTTP 消息体标准定义（完整版 · 规范排版+内容补全+无语法残缺）
## 一、通用响应消息体结构
HTTP 所有接口的**统一响应消息体**均采用标准 JSON 格式，整体固定包含三个核心字段，所有接口返回格式遵循此规范，保证前后端交互一致性。

### 核心字段清单
| 字段名 | 数据类型 | 字段描述 | 是否必填 | 补充说明 |
| ------ | -------- | -------- | -------- | -------- |
| code   | Integer  | 业务状态码，标识请求最终处理结果 | ✅ 是    | 全局统一规则设计，无例外场景 |
| msg    | String   | 处理状态描述/错误详情信息       | ✅ 是    | 成功简洁、失败详尽，便于问题定位 |
| data   | Object   | 业务响应数据载体                | ❌ 否    | 成功时返回业务数据，失败时可空/返回错误上下文，结构按需扩展 |

---

## 二、状态码(code) 标准设计规范
### 2.1 状态码结构规则
状态码为纯整型数字，采用 **三段式固定结构** 设计：`{异常类别:3位}{异常系统:4位}{业务自定义:4位}`，**总长度11位**。
✅ 设计合理性：11位整型最大值为 `99999999999`，远小于Java/Rust/Go等主流语言的整型上限（`2,147,483,647`），完全无溢出风险。

### 2.2 各分段详细说明
| 分段名称 | 位数 | 取值规则 & 含义 | 示例值 |
| -------- | ---- | --------------- | ------ |
| 异常类别 | 3    | 基准状态码，复用HTTP语义规则，仅允许3类核心值<br>▫️`200` = 请求处理成功<br>▫️`400` = 客户端侧异常（参数、格式、权限等）<br>▫️`500` = 服务端侧异常（系统、数据库、第三方调用等） | 200 / 400 / 500 |
| 异常系统 | 4    | 微服务/业务模块唯一标识，业务自定义分配<br>作用：区分异常归属的服务/模块，便于快速定位问题域 | 1001（用户模块）、2003（订单模块）、3005（支付模块） |
| 业务自定义 | 4 | 具体的业务错误码，模块内唯一<br>作用：区分同模块下的不同具体异常场景 | 0001（参数缺失）、0002（格式错误）、0105（数据不存在） |

### 2.3 状态码简化写法
- 全局通用成功：直接使用极简值 `200` 即可，无需补全11位
- 通用异常场景：可直接使用3位基础值（`400`=通用参数异常、`500`=通用系统异常）
- 精细化异常场景：必须使用完整11位状态码，保证异常精准定位

### 2.4 标准状态码示例
- `200` → 全局通用请求成功
- `40010010001` → 客户端异常 + 用户模块 + 用户ID参数缺失
- `40020030005` → 客户端异常 + 订单模块 + 订单号格式非法
- `50030050002` → 服务端异常 + 支付模块 + 第三方支付接口调用失败

### 2.5 状态码校验规则
1. 数值范围：必须为合法正整数，无负数场景
2. 格式合法：3位基准段仅允许 `200/400/500`，其余分段为业务自定义数字，禁止非数字字符
3. 唯一性：`异常系统+业务自定义` 组合需**全局唯一**，禁止不同异常场景复用同一编码

---

## 三、消息描述(msg) 规范
### 3.1 核心原则
- 成功场景：描述**简洁统一**，推荐固定值 `Success`，无需多余内容
- 失败场景：描述**精准详尽**，必须包含「异常类型+关键信息」，便于前后端快速定位问题，禁止无意义文案（如：`error`/`失败`）
### 3.2 格式要求
- 字符集：UTF-8 编码，支持中英文描述
- 长度限制：建议单条描述≤255个字符，避免超长文本传输
- 国际化支持：可根据请求头 `Accept-Language` 动态返回多语言文案（如：中文 `参数缺失：用户ID不能为空` / 英文 `Invalid parameter: user_id is missing`）
### 3.3 标准示例
✅ 成功：`Success`
✅ 参数异常：`Invalid parameter: user_id must be a positive integer`
✅ 系统异常：`Database connection failed: timeout when connect to mysql`
✅ 业务异常：`Business exception: order status is closed, cannot pay`

---

## 四、数据载体(data) 规范
`data` 是**灵活扩展字段**，核心作用是承载业务相关的实际数据，无固定结构，完全根据接口业务需求定义，遵循「按需返回」原则：
### 4.1 成功场景
返回接口约定的**业务核心数据**，支持任意层级的JSON嵌套对象/数组，无格式限制。
```json
{
  "user_id": 10001,
  "username": "zhangsan",
  "user_info": {
    "phone": "13800138000",
    "email": "test@example.com"
  },
  "roles": ["admin", "user"]
}
```

### 4.2 失败场景
两种合法处理方式，任选其一即可，全局保持统一：
1. 无补充信息：直接返回**空对象 `{}`**，极简规范
2. 有错误上下文：返回错误相关的辅助信息，便于前端精准提示，推荐结构：
```json
{
  "error_field": "user_id",
  "error_detail": "required field, cannot be null or empty",
  "error_rule": "must be a positive integer greater than 0"
}
```

---

## 五、完整响应示例（全部场景）
### ✅ 场景1：通用成功响应（最常用）
```json
{
  "code": 200,
  "msg": "Success",
  "data": {
    "user_id": 123,
    "username": "example",
    "create_time": "2026-01-18 10:00:00"
  }
}
```

### ✅ 场景2：参数错误响应（客户端异常）
```json
{
  "code": 40010010001,
  "msg": "Invalid parameter: user_id is missing, required field",
  "data": {
    "error_field": "user_id",
    "error_detail": "must be passed in the request parameter"
  }
}
```

### ✅ 场景3：系统错误响应（服务端异常）
```json
{
  "code": 50020030002,
  "msg": "Database connection failed: connection timeout after 3000ms",
  "data": {}
}
```

### ✅ 场景4：业务规则异常响应（客户端异常）
```json
{
  "code": 40020030010,
  "msg": "Business exception: order amount cannot be less than 0",
  "data": {
    "error_field": "order_amount",
    "error_detail": "value: -100, rule: must ≥ 0"
  }
}
```

---

## 六、分页查询接口 专属响应格式
### 6.1 适用场景
所有带分页能力的列表查询接口，**统一复用此格式**，将分页相关数据和业务列表数据封装在 `data` 字段内，实现分页接口标准化，降低前后端对接成本。

### 6.2 分页data字段固定结构
| 字段名 | 数据类型 | 描述 | 是否必填 | 补充说明 |
| ------ | -------- | ---- | -------- | -------- |
| total  | Integer  | 符合查询条件的**数据总条数** | ✅ 是    | 非当前页条数，是全局总条数 |
| page   | Integer  | 当前请求的页码 | ✅ 是    | 页码从 **1** 开始计数，无0页/负数页 |
| size   | Integer  | 每页展示的数据条数 | ✅ 是    | 前端传入的分页大小，如10/20/50 |
| pages  | Integer  | 数据的**总页数** | ✅ 是    | 计算规则：`pages = ceil(total / size)`，向上取整 |
| list   | Array    | 当前页的业务数据列表 | ✅ 是    | 列表项为业务对象，结构按需定义 |

### 6.3 分页响应特殊规则
- 分页查询**成功**：`list` 返回当前页数据，无数据时返回**空数组 `[]`**
- 分页查询**失败**：`list` 固定返回空数组 `[]`，`total/page/size/pages` 仍返回请求入参值，保证前端分页组件正常渲染
- 无匹配数据：`total=0`、`pages=0`、`list=[]`，其余字段按请求参数返回

### 6.4 分页接口完整响应示例
#### ✅ 分页查询成功（有数据）
```json
{
  "code": 200,
  "msg": "Success",
  "data": {
    "total": 100,
    "page": 1,
    "size": 10,
    "pages": 10,
    "list": [
      {
        "user_id": 123,
        "username": "example",
        "create_time": "2026-01-01 00:00:00"
      },
      {
        "user_id": 124,
        "username": "test",
        "create_time": "2026-01-02 00:00:00"
      }
    ]
  }
}
```

#### ✅ 分页查询成功（无匹配数据）
```json
{
  "code": 200,
  "msg": "Success",
  "data": {
    "total": 0,
    "page": 1,
    "size": 10,
    "pages": 0,
    "list": []
  }
}
```

#### ✅ 分页查询失败（参数错误）
```json
{
  "code": 40010020003,
  "msg": "Invalid parameter: page must be a positive integer, current value: 0",
  "data": {
    "total": 0,
    "page": 0,
    "size": 10,
    "pages": 0,
    "list": [],
    "error_field": "page"
  }
}
```

---

## 七、全局通用注意事项（规范约束，必遵循）
1. **格式一致性**：所有HTTP接口（RESTful/OpenAPI）统一遵循本消息体规范，禁止自定义其他返回格式，保证前后端交互无差异化。
2. **状态码唯一性**：`{异常系统}{业务自定义}` 组合必须全局唯一，项目需维护「状态码字典表」，避免不同异常场景编码冲突。
3. **data字段扩展性**：支持任意层级的JSON嵌套，可满足简单数据、复杂业务对象、列表数据等所有场景，无格式限制。
4. **空值处理**：禁止返回 `null` 作为顶层字段值，失败时`data`用空对象`{}`，列表无数据时用空数组`[]`。
5. **数值类型**：所有数字型字段（code/total/page/size等）均为`Integer`整型，禁止返回字符串格式数字（如：`"code": "200"` 非法）。
6. **异常兜底**：服务端发生未捕获的未知异常时，统一返回 `code:500`、`msg:Server internal error`、`data:{}`，避免返回堆栈信息给前端。

---

### 补充说明
本文档为 **HTTP响应消息体** 标准定义，所有规则均为工程化最佳实践，兼顾「规范性」和「灵活性」，适用于后端所有语言（Rust/Java/Go/PHP）和前端所有框架，可直接落地使用。